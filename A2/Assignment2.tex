\documentclass[11pt]{article}
\renewcommand\thesection{Part \Alph{section}.}
\renewcommand\thesubsection{\thesection\arabic{subsection}.}
\setlength{\abovecaptionskip}{15pt plus 3pt minus 2pt}
\usepackage{amsfonts, amsmath}
\usepackage{xcolor}
\usepackage{latexsym,enumitem}
\usepackage{hyperref}
\usepackage{graphicx}
\newcommand{\poly}{\mathsf{poly}}
\newcommand{\clientmsg}{\mathsf{cmsg}}
\newcommand{\cookie}{\mathsf{cookie}}
\newcommand{\compress}{\mathsf{compress}}
\newcommand{\zlib}{\mathsf{zlib}}
\newcommand{\AES}{\mathsf{AES}}
\newcommand{\encrypt}{\mathsf{encrypt}}
\newcommand{\MAC}{\mathrm{mac}}
\newcommand{\mac}{\mathrm{mac}}
\newcommand{\UFCMA}{\mathsf{UFCMA}}
\newcommand{\sign}{\mathsf{Sign}}
\newcommand{\verify}{\mathsf{Verify}}
\newcommand{\UFCMAU}{\UFCMA \mhyphen \mathsf{Unique}}
\newcommand{\CPA}{\mathsf{CPA}}
\newcommand{\INDCPAUQ}{\CPA\mhyphen \mathsf{Unique}}
\newcommand{\uniq}{\mathrm{uq}}
\newcommand{\func}[1]{\mathsf{Func}\left[ #1 \right]}
\newcommand{\TODO}[1]{\textcolor{red}{TODO : #1}}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdfpagemode=FullScreen,
}


\setlength{\oddsidemargin}{.25in}
\setlength{\evensidemargin}{.25in}
\setlength{\textwidth}{6in}
\setlength{\topmargin}{-0.4in}
\setlength{\textheight}{8.5in}
\mathchardef\mhyphen="2D


\newcommand{\handout}[5]{
   \renewcommand{\thepage}{#1-\arabic{page}}
   \noindent
   \begin{center}
   \framebox{
      \vbox{
    \hbox to 5.78in { {\bf COL759 Cryptography} \hfill #2 }
       \vspace{4mm}
       \hbox to 5.78in { {\Large \hfill #5  \hfill} }
       \vspace{2mm}
       \hbox to 5.78in { {\it #3 \hfill #4} }
      }
   }
   \end{center}
   \vspace*{4mm}
}

\newcommand{\ho}[4]{\handout{#1}{#2}{Instructor:
#3}{Due Date: #4}{Problem Set #1}}

\newtheorem{definition}{Definition}
\newtheorem{problem}{Problem}

\newcommand{\prob}[1]{\mathsf{Pr}\left[ #1 \right]}
\newcommand{\bit}{\left\{0, 1\right\}}
\newcommand{\enc}{\mathsf{Enc}}
\newcommand{\dec}{\mathsf{Dec}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\abs}[1]{\left| #1 \right|}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\calB}{\mathcal{B}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calG}{\mathcal{G}}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\calI}{\mathcal{I}}
\newcommand{\calK}{\mathcal{K}}
\newcommand{\kmac}{\calK_{\mathrm{mac}}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calX}{\mathcal{X}}
\newcommand{\calY}{\mathcal{Y}}

\newcommand{\inparen}[1]{\left{ #1 \right}}
\newcommand{\probtwo}[2]{\mathsf{Pr}_{#1}\left[ #2 \right]}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\ct}{\mathsf{ct}}


\newlength{\protowidth}
\newcommand{\pprotocol}[5]{
{\begin{figure*}[#3]
\begin{center}
\setlength{\protowidth}{\textwidth}
\addtolength{\protowidth}{-3\intextsep}

\fbox{
        \small
        \hbox{\quad
        \begin{minipage}{\protowidth}
    \begin{center}
    {\bf #1}
    \end{center}
        #5
        \end{minipage}
        \quad}

        }
        
\end{center}
\vspace{-4ex}
\caption{{#4} #2}
\end{figure*}
} }

% the first arg is name of security game
% the second arg is caption
% the third arg is the game description
% the label needs to be included 
\newcommand{\securitygame}[4]{
   \pprotocol{#1}{#2}{tbh!}{#3}{#4}
}

\newcommand{\constr}[4]{
   \pprotocol{#1}{#2}{tbh!}{#3}{#4}
}

% \usepackage[most]{tcolorbox}

% \definecolor{codegray}{rgb}{0.98,0.97,0.93}
% \definecolor{cottoncandy}{rgb}{1.0, 0.74, 0.85}
% \definecolor{darkcerulean}{rgb}{0.03, 0.27, 0.49}
\definecolor{darkcyan}{rgb}{0.0, 0.50, 0.45}
% \newtcolorbox{constbox}[1][]{every float=\centering,breakable,enhanced,colback=white,colframe=codegray!50!black}

% \definecolor{beige}{rgb}{0.96, 0.96, 0.86}

% \newtcolorbox{cktbox}[1][]{every float=\centering,breakable,enhanced,colback=beige,colframe=codegray!50!black}

% \newcommand{\const}[1]{
%    \begin{constbox}
%          #1
%    \end{constbox}
% }



\begin{document}
    \ho{2}{Semester 1, 2023-24}{Venkata K}{27 September 2023}


    \paragraph{Instructions:}
    \begin{itemize}
        \item Assignment must be done in groups of size at most $2$. Each group must submit one pdf on Gradescope, and mention the partner's name (if any). 
        \item The questions are divided into two parts. The first section (\ref{sec:partA}) consists of theoretical/coding questions (32 marks). In the second part, you can either attempt the coding questions (in \ref{sec:coding}) or the theoretical question (in \ref{sec:theoretical}). In case both sections are attempted, we will consider the higher score. 
        \item All solutions must be typeset in LaTeX. For the coding questions, provide a brief explanation of your approach and upload the relevant files on Gradescope. 
        \item For the coding questions, you would need to install the \texttt{pycryptodome} python3 package to run the given files. Installation instructions can be found \href{https://pypi.org/project/pycryptodome/}{\color{red}on this link}.
        \item Students who are interested in a BTP/MTP in theoretical cryptography are strongly encouraged to attempt the theoretical question (\ref{sec:theoretical}). 
        \item (Optional) Discuss how much time was spent on each problem. This will not be used for evaluation. We will use this for calibrating future assignments. 
    \end{itemize}


    \paragraph{Notations:}
    \begin{itemize}
        \item $\bit^{\leq \ell}$ denotes the set of all strings of length at most $\ell$. For any string $x\in \bit^{\ell}$ and $i \in \set{1, \ldots,\ell}$, $x[i]$ denotes the $i^{th}$ bit of $x$. 
        \item $x ~||~ y$ denotes the concatenation of $x$ and $y$. 
    \end{itemize}

    \newpage 
    

    \section{(32 marks)}
    \label{sec:partA}
    \begin{enumerate}

        \item (8 marks) \textbf{Cryptosystems secure against side-channel attacks}\footnote{This problem is taken from the textbook (\cite{BonehShoup}, 4.14). You can refer to the textbook for hints.} 

        When we were discussing the padding oracle attack, we also talked about \emph{timing attacks} --- attacks that exploit the amount of time required for decryption. As was pointed out by one of the students in class, it is important to consider such attacks for all cryptographic primitives. 

        Timing attacks are a special case of a broad class of vulnerabilities called \emph{side-channel attacks}. These include attacks based on power analysis, studying the amount of electromagnetic radiation, etc. How do we capture such attacks in a theoretical security game? This is done by allowing the adversary to leak some bounded information about the secret key. In this problem, we define leakage resilience for pseudorandom functions. 

        \securitygame{Security Game for Leakage resilient PRFs}{$\ell$-Leakage Resilient PRF}{}{

            Let $F: \calK \times \calX \to \calY$ be a keyed function. 
            \begin{enumerate} 
                \item Challenger chooses a bit $b \gets \{0,1\}$ and key $k \gets \calK$. If $b = 0$, challenger sets function $F_0 \equiv F (k, \cdot)$. If $b = 1$, challenger chooses a truly random function $F_1 \gets \func{\calX, \calY}$.

                \item \textbf{Leakage query:} First, the adversary can query for any $\ell$ bits of the key $k$. The challenger sends the corresponding bits. \footnote{This leakage represents the information that the adversary learns about the secret key. The general leakage-resilience security game allows the adversary to receive any arbitrary function of the secret key. Here, we are working with a weaker definition where the adversary gets a subset of the key's bits. } Note that even if $b=1$, the challenger sends these $\ell$ bits of the key $k$. 
                \item \textbf{PRF queries:} After receiving the leakage, the adversary can send polynomially many queries (adaptively). For each query $x_i$, the challenger sends $F_b(x_i)$. 
                \item $\calA$ finally sends a guess $b'$ and wins if $b' = b$.
            \end{enumerate}
        }
         
        A keyed function $F$ is said to be an $\ell$-leakage resilient PRF if no ppt adversary can win the above security game with non-negligible advantage. 

        \vspace{10pt}

        Having defined leakage resilience, a natural question is whether we get leakage resilience \emph{for free}. That is, given any secure PRF, is it already $\ell$-leakage resilient for some $\ell>0$? Unfortunately, no! There exist secure PRFs where leaking even one bit of the key breaks PRF security. 
        
        
        Let $F: \bit^n \times \bit^n \to \bit^n$ be a secure PRF. Construct a new PRF $F'$ with appropriate key space $\calK'$, input space $\calX'$ and output space $\calY'$ such that the $F'$ is a secure PRF (assuming $F$ is); however, if the adversary learns even one bit of the key, then the PRF is no longer secure. 
        
        \begin{enumerate}
            \item Prove (using formal reduction(s)) that if $F$ is a secure PRF, then $F'$ is also a secure PRF. 

            \item Show that $F'$ does not satisfy 1-leakage resilience. 
        \end{enumerate}
        \newpage 
        \item (8 marks) \textbf{MACs: unique queries vs non-unique queries}

        In the minor, we saw how to convert a MAC with randomized signing into one which has deterministic signing. This also ensures that if an adversary sends repeated queries for the same message, it gets the same response (and therefore repeated queries are useless when the signing algorithm is deterministic). However, is this true in general? 
        
        Consider the UFCMA security game for MACs (Figure 18 in the lecture notes), but the adversary is allowed only \textbf{unique} signature queries. A MAC scheme is said to be \emph{unforgeable against unique chosen message attacks} ($\UFCMAU$) if, for any ppt adversary $\calA$, the advantage in this restricted security game is negligible. This security game is strictly weaker than the regular MAC security game. 

        \vspace{10pt}


        Let $F: \bit^n \times \bit^n \to \bit^n$ be a secure pseudorandom function. Use $F$ to construct a MAC scheme $\calI_{\uniq}  = (\sign_{\uniq}$, $\verify_{\uniq})$ with message space $\bit^n$, and appropriate key space  that is $\UFCMAU$ secure, but not $\UFCMA$ secure. 

        \begin{enumerate}
            \item Describe the signing and verification algorithms.  
            
            \item Show that the MAC scheme $\calI_{\uniq}$ is $\UFCMAU$ secure, assuming $F$ is a secure pseudorandom function. If your security proof requires multiple hybrid-games, describe the games formally, and complete the proof by giving appropriate reductions.

            \item Show that the MAC scheme $\calI_{\uniq}$ is not $\UFCMA$ secure. Construct a ppt adversary $\calA$ that wins the $\UFCMA$ security game against $\calI_{\uniq}$ with non-negligible advantage. Analyse the success probability of $\calA$. 
        \end{enumerate}



        \newpage 
        \item (2 marks) \textbf{A mistake in the lecture notes}

        In class, we discussed two definitions for MACs: one with verification queries, and one without. We argued that if there exists a p.p.t. adversary that makes $q_v$ verification queries and wins with probability $\epsilon$, then there exists a p.p.t. adversary that makes no queries and wins with probability at least $\epsilon/q_v$. 

        Based on one of the in-class suggestions, I had included the following in the notes: 
        \begin{quote}
            \textcolor{darkcyan}{If every message has a unique signature, then verification queries do not give any additional power to the adversary. For any p.p.t. adversary $\calA$ that wins the security game in Figure 19 with probability $\epsilon$ using $q_s$ signing queries and $q_v$ verification queries, there exists a p.p.t. reduction $\calB$ that wins the security game in Figure 18 with probability $\epsilon$ using $q_s + q_v$ signing queries. On receiving a verification query $(m, \sigma)$, the reduction algorithm $\calB$ sends $m$ to the challenger, and receives a signature $\sigma'$. If $\sigma = \sigma'$, then it sends $1$, else it sends $0$.}
        \end{quote} 

        In the above (informal and flawed) argument, we did not use the fact that $\calA$ is p.p.t. As a result, using the same argument, we can state that for any adversary $\calA$ that runs in time $t$, makes $q_s$ signing queries and $q_v$ verification queries and wins with probability $\epsilon$, there exists a reduction that makes at most $q_s+q_v$ signing queries, runs in time $t + \poly(\lambda)\cdot (q_s + q_v)$ and wins with probability $\epsilon$. 

        \vspace{10pt} 

        Show that this argument is incorrect. Let $\calI$ be a MAC scheme where each message has a unique valid signature. Propose an adversary that runs in time $t$, makes $q_s$ signing queries, $q_v$ verification queries and wins with probability $1$ (note that here we did not assume $t, q_s$ or $q_v$ are polynomial). However, the above reduction does not win with probability $1$.  

        \vspace{10pt} 

        The important take-home message here is that one should avoid informal arguments (especially when dealing with MACs). Thanks to one of the students for bringing this to my attention. 

        \newpage 
        \item (5 marks) \textbf{Even-Mansour instantiated with a bad permutation} 

        Even-Mansour cipher has been proved to be secure in the \textcolor{cyan}{\emph{ideal permutation model}}. However, using a ``bad" permutation may lead to attacks in the real world. In this question, your goal is to understand the given implementation, find vulnerabilities based on the public permutation being used and code an attack to break PRP security of the scheme using this permutation. Hopefully, this question successfully conveys that security in the ideal permutation model does not translate directly to security in the real world and that one needs to be rather careful while implementing these in practice.
       
        \textbf{Files Given:} You are given the following Python files on Teams (\texttt{COL759\_A2\_Coding1.zip})
        \begin{itemize}
            \item \texttt{perm.py}:
                \begin{itemize}
                    \item This file has a \texttt{prp\_oracle} class which has randomly generated large prime $p$ and two keys $k_1$, $k_2$ which is used by the scheme.
                    \item It has two functions that you can use. The first one is called \texttt{pi\_func(x)} which takes an input number $x$ between $0$ to $p-1$ and returns $\pi(x)$.
                    \item The second function is called \texttt{oracle(x)} which takes an input number x between 0 to p-1 and 
                    \begin{itemize}
                        \item If $b=0$ then it outputs PRP evaluation on $x$.
                        \item If $b=1$ then it outputs random permutation evaluation on $x$.
                    \end{itemize}
                    \item There is also a third function which you don’t have to use - \texttt{prp(x)}. It takes an input number $x$ between $0$ to $p-1$ and outputs the PRP evaluation on $x$. You can look at it to understand how the PRP is implemented.
                \end{itemize}
            \item \texttt{attack.py}:
                \begin{itemize}
                    \item You are required to implement the \texttt{attack(oracle, pi\_func, p)} function in this file.
                    \item It is supposed to return the correct guess of $b$ (either 0 or 1) which is sampled by the challenger at the start.
                    \item You are allowed to make at most five calls to oracle(x). After five calls, the oracle will return \texttt{None}.                      
                \end{itemize}
        \end{itemize}
        
        \textbf{Instructions:}
        \begin{itemize}
            \item You are only required to submit \texttt{attack.py} on Gradescope in the \texttt{Assignment2 Coding1} with your implementation of \texttt{attack(oracle, pi\_func, p)}. You don’t need to submit any other files. All test cases are public, you should be able to find the number of test cases that your code passes on Gradescope.
            \item Provide a high-level description of your attack in the pdf submission.
        \end{itemize}

        \textbf{NOTE:} Your grade for this problem will be based on how many queries you will use.

        \newpage 
        
        

        \item (4 marks) \textbf{3-round Luby-Rackoff with inversion queries}
        
        In class we discussed that the 3-round Luby-Rackoff scheme is a secure PRP. One of the students asked whether there's any benefit in having more rounds. Having more rounds helps us achieve stronger security. In particular, the 4-round construction is a \textcolor{cyan}{\emph{strong pseudorandom permutation}}, but the 3-round construction is not. Below, we present the definition of strong PRPs. Your task is to show that the 3-round construction is NOT a strong PRP.
        
        \begin{definition}\text{Strong PRP:}
            A keyed function $F : \mathcal{K} \times \mathcal{X}  \mapsto \mathcal{X}$, together with an inverse function $F^{-1} :\mathcal{K} \times \mathcal{X} \mapsto \mathcal{X}$, is a strong pseudorandom permutation (sPRP) if $F, F^{-1}$ are efficient, and the following correctness and security properties hold:
            \begin{itemize}
                \item Correctness: for any $k \in \mathcal{K}$, $x \in \mathcal{X}$, $F^{-1}(k, F(k, x) ) = x$.
                \item Security: for any p.p.t. adversary $\calA$,
                $\abs{\Pr[\calA \text{ wins the strong PRP security game}] - \frac{1}{2}}$ is negligible, where the strong PRP security game is defined in figure below.
            \end{itemize}
        \end{definition}
        
        \securitygame{Security Game: Strong PRP}{Strong PRP}{}{
            \begin{enumerate} 
                \item Challenger chooses a bit $b \gets \{0,1\}$. If $b = 0$, challenger chooses a key $k \gets \mathcal{K}$ and sets function $F_0 \equiv F (k, \cdot)$. If $b = 1$, challenger chooses a truly random function $F_1$ from the set of all permutations mapping $\mathcal{X}$ to $\mathcal{X}$.
    
                \item The adversary can make the following two types of queries:
                \begin{itemize}
                    \item Permutation: For query $x \in \mathcal{X}$, the challenger sends $F_b(x)$.
                    \item Inverse: For query $x \in \mathcal{X}$, the challenger sends $F_b^{-1}(x)$
                \end{itemize}
    
                \item After polynomially many queries by the adversary, it finally sends a guess $b'$ and wins if $b' = b$.
            \end{enumerate}
        }
         
        Specifically, given access to only the permutation, it is impossible to break security of the 3 round Luby-Rackoff scheme. But, you have been provided oracle access to the permutation as well as its inverse. Your goal is to break sPRP security of the Luby-Rackoff scheme.

         
        \textbf{Files Given:} You are given the following Python files on Teams (\texttt{COL759\_A2\_Coding2.zip})
            \begin{itemize}
                \item \texttt{attack.py}: Refer to the comments in this file for more information
            \end{itemize}
            \textbf{Instructions:}
        \begin{itemize}
            \item You are only required to submit \texttt{attack.py} on Gradescope in the \texttt{Assignment2 Coding2} with your implementation of \texttt{predict(permute, inverse\_permute)}. You don’t need to submit any other files. All test cases are public, you should be able to find the number of test cases that your code passes on Gradescope.
            \item Provide a high-level description of your attack in the pdf submission.
        \end{itemize}
    
        \textbf{NOTE:} Your grade for this problem will be based on how many queries you will use.
      

        
       
        \newpage 
        \item (5 marks) \textbf{CBC mode with bad initialization}
      
        \textbf{Problem Description:} CBC mode is a commonly used provably secure encryption scheme. While the encryption scheme is in itself simple, it is still possible for things to go horribly wrong in practice when in order to make the implementation of the scheme simpler, implementations end up using ``bad" initialization vector (IV), such as directly picking up the last block of the previous ciphertext or even the key itself. In this problem, we will explore an attack on the latter implementation. Hopefully, this shows that something as simple as choosing the IV can turn out to be fatal if done incorrectly and that a random IV is the correct way to use CBC mode of encryption.

        \begin{figure}[h]
            \centering
            \includegraphics[scale=0.5]{cbc.png}
        \end{figure}

        For the purpose of this question, consider the IV supplied at the start to be same as the key used with the block cipher(AES).

        You are given an encryption of some message, and you are supposed to recover the secret key by making only one query to the decryption oracle. 

        \emph{How this attack is applicable in the real world --- consider the following scenario: there is a server that communicates with clients using a shared secret key. Whenever the server receives a `bogus' ciphertext (that is, a ciphertext that results in some nonsensical decryption), it outputs an error message containing the decrypted message (this happens quite often in practice when code for debugging is pushed into production). If the server receives a proper ciphertext, it computes the next message and outputs an encryption of the next message. }

        \emph{Therefore, the attacker has access to ciphertexts, and also has access to a partial `decryption oracle'. In this assignment, we are giving you access to the full decryption oracle. }

        \textbf{Files Given:} You are given the following Python files on Teams (\texttt{COL759\_A2\_Coding3.zip})
            \begin{itemize}
                \item \texttt{decrypt.py}:
                    \begin{itemize}
                        \item This file has a \texttt{decryption\_oracle} class which has 16-byte key for the AES scheme hard-coded (the keys will be changed during autograding)
                        \item It has a function called \texttt{decrypt(ct)}, which takes a byte array of size $48$ and returns the decrypted message $m$ of $48$ bytes in the byte format.
                        
                        An example of how the message and the ciphertext (format of both) will look like is given below(not indicative of actual size used in this):
                        
                        $m = $\verb|b'd2\xad\xbc\x8d\xc1R\xcc\xa3\x8c\x9d\x10\x8d\xfc'|
                        
                        $ct = [137, 110, 41, 18, 99, 62, 3, 4, 197, 186, 163, 215, 12, 48, 176, 44]$
                        \item This \texttt{decrypt} function can be used only once for your attack, If you use it for more than once then it will just return None.
                    \end{itemize}
                \item \texttt{attack.py}:
                    \begin{itemize}
                        \item You are required to implement the \texttt{attack(ciphertext, decrypt)} function in this file.
                        \item You are given a cipher on some message of $48$ bytes length(fixed).
                        \item It is supposed to return the key which is used during the encryption and decryption of the scheme.
                        \item You have to return the key in byte format only.
                        \item You are allowed to make calls to \texttt{decrypt(ct)} function of \texttt{decrypt.py}.                
                    \end{itemize}
            \end{itemize}
        
        
        \textbf{Instructions:}
        \begin{itemize}
            \item You are only required to submit \texttt{attack.py} on Gradescope in the \texttt{Assignment2 Coding3} with your implementation of \texttt{attack(ciphertext, decrypt)}. You don’t need to submit any other files. All test cases are public, you should be able to find the number of test cases that your code passes on Gradescope.
            \item Provide a high-level description of your attack in the pdf submission.
        \end{itemize}
    
        \newpage 
    \end{enumerate}

    \section{Coding/Theoretical Problems (8 marks) }
        \subsection{Coding Problem: Padding Oracle Attack}
        \label{sec:coding}
            Consider the following encryption scheme:

            \begin{itemize}
                \item $\enc(k, m)$: The message $m$ is an arbitrary sequence of bytes. Here the key $k$ is a 16 byte string. We use $\AES$ in CBC mode to encrypt this message. Since $\AES$ can only handle messages whose length (in bits) is a multiple of $128$, we have to pad $m$ appropriately. 

                \vspace{5pt}

                \underline{Padding Scheme:} Instead of padding at the right-most end, we would instead pad at the left-most end (as suggested by one of the students in class). Let $p$ be the number of bytes to be padded -- then include the number $p$ (in binary) in each of the $p$ bytes.

                \vspace{5pt}
                Examples:
                \begin{itemize}
                    \item $m = (11~ 42~ 33~ 01~ 89~ 12)$. This message is $6$ bytes long. We need to pad it with $10$ bytes. The resulting message $m'$ would be $$m' = (\textcolor{brown}{10 ~10~ 10~ 10~ 10~ 10~ 10~ 10~ 10~ 10}~ 11~ 42~ 33~ 01~ 89~ 12).$$

                    \item $m = (02 ~ 02~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 16)$. This message is $16$ bytes long. Add a new padding block to avoid ambiguity. The padded message $$m' = (\textcolor{brown}{16~ 16~ \ldots  16~ 16} ~ 02~ 02~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 00~ 16).$$
                \end{itemize}




                \item $\dec(\ct, k):$ Decryption algorithm simply decrypts the ciphertext to obtain the padded message $m' = (y_1, y_2, ..., y_{\ell})$ where each $y_{i}$ is $16$ bytes long. It checks if $y_1$ is a valid padded string. That is, check that the first byte of $y_1$ is a number between 1 and 16. If the number is $z$, then check that the next $z-1$ bytes after it have the value $z$. If any of these is violated, output \textcolor{red}{``Error: Bad Padding''}. Otherwise, output the decrypted string (without the padding). 

            \end{itemize}


            \textbf{Files Given:} Since the messages and the cipher-texts are arbitrary sequences of bytes, we represent each of them by a list of integers within the range $[0, ~255]$. You are given the following \texttt{python} files on MS Teams (\texttt{A2\_Coding\_Students.zip}):
            \begin{itemize}
                \item \texttt{encrypt.py}:
                    \begin{itemize}
                        \item This file has a 16-bit key hardcoded into it for the $\AES$ scheme
                        \item It has a function called \texttt{encrypt(message)}, which takes a list of integers as input,  pads it appropriately and returns the encrypted bytes
                        \item This script can be used to generate cipher-texts with the given key. You can use it to check the correctness of your code.
                    \end{itemize}
                \item \texttt{decrypt.py}:
                    \begin{itemize}
                        \item This file has the same key hardcoded for $\AES$ as in \texttt{encrypt.py}
                        \item It has a function called \texttt{check\_padding(encd)}, which takes a ciphertext as input (in the form of an integer list), decrypts it and checks for a valid padding.
                        \item It returns 0 if it was a valid padding, else returns 2. It does NOT return the decrypted message
                    \end{itemize}
                \item \texttt{attack.py}:
                    \begin{itemize}
                        \item You are required to implement your attack in this file. The function to be implemented is \texttt{attack(cipher\_text)}
                        \item It is supposed to take a ciphertext as input, and the return the original message (as a list of integers)
                        \item You are allowed to make calls to \texttt{check\_padding()} from \texttt{decrypt.py}
                    \end{itemize}
            \end{itemize}
            
        \textbf{Instructions:}
        \begin{itemize}
            \item You are only required to submit \texttt{attack.py}, with your implementation of \texttt{attack()}. You don't need to submit \texttt{encrypt.py}, \texttt{decrypt.py}.
            \item Submit the \texttt{attack.py} file on Gradescope in the \texttt{Assignment2 Coding4}
            \item Your submission will be checked on ciphertexts which are encryptions of some messages with some key $k$
            \item During grading, we would change the key so you cannot simply decrypt the ciphertext
        \end{itemize}
            
   
        \newpage 
        \subsection{Theoretical Problem (8 marks)}
        \label{sec:theoretical}
        \label{qn:theory}


        Consider a variant of the CPA security definition for secret key encryption, called $\INDCPAUQ$. In this security definition, the adversary is allowed to send only unique encryption queries. The challenge messages, however, could be one of the queried messages.

        Let $F$ be a secure pseudorandom function. Let $\calE = (\enc, \dec)$ be a CPA secure encryption scheme with keyspace $\{0,1\}^n$ and message space $\{0, 1\}^n$. Construct an encryption scheme $\calE_{\uniq} = (\enc_{\uniq}, \dec_{\uniq})$ such that the scheme is $\INDCPAUQ$ secure, but not CPA secure. 

        \begin{enumerate}
      
            \item Formally define the keyspace and the algorithms of $\calE_{\uniq}$, using $\enc$, $\dec$ and $F$ only. Note that the domain and range of $F$ can be chosen appropriately. 
            \item Show that $\calE_{\uniq}$ is $\INDCPAUQ$ secure, assuming $(\enc, \dec)$ is CPA secure and $F$ is a secure pseudorandom function. Define appropriate hybrid experiment(s) for this proof. 
            \item Show that $\calE_{\uniq}$ is not CPA secure by constructing a ppt algorithm $\calA$ that wins the CPA security game against $\calE_{\uniq}$ with non-negligible advantage.  
        \end{enumerate}

    \hrule 

    \bibliographystyle{alpha}
    \bibliography{references}


\end{document}
